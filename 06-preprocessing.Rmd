# 데이터 전처리


## dplyr 패키지


### dplyr 패키지 소개
+ 탐색적 자료분석, 데이터 가공에 매우 유용하고 편리한 함수 제공
+ 적용 대상에 따른 dplyr 함수
  + **행**: filter(), arrange()
  + **열**: select(), rename(), mutate(), relocate()
  + **그룹**: summarise(), group_by()
  + **테이블**
+ [예제] 2013년 뉴욕시 출발 항공편 데이터셋 flights

|변수|설명|
|:---:|:------------|
|year|출발 연도|
|month|출발 월|
|day|출발 일|
|dep_time|실제 출발 시간(HHMM 또는 HMM)|
|arr_time|실제 도착 시간(HHMM 또는 HMM)|
|sched_dep_time|예정된 출발 시간(HHMM 또는 HMM)|
|sched_arr_time|예정된 도착 시간(HHMM 또는 HMM)|
|dep_delay|출발 지연 시간(분)|
|arr_delay|도착 지연 시간(분)|
|carrier|항공사 약어|
|flight|항공편 번호|
|tailnum|비행기 식별 번호|
|origin|출발지|
|dest|목적지|
|air_time|비행 시간(분)|
|distance|비행 거리(miles)|
|hour|예정된 출발 시간; 시|
|minute|예정된 출발 시간; 분|
|time_hour|예정된 비행 날짜 및 시간(POSIXct date)|

```{r eval = FALSE}
library(dplyr)
library(nycflights13)
glimpse(flights)
```


### 행 관련 함수


#### filter() 함수
+ 조건에 맞는 행 추출
+ ```%in%``` 연산자 - 왼쪽의 값이 오른쪽에 있는 값들 중 어느 하나와 같으면 TRUE

```{r eval = FALSE}
flights %>% filter(arr_delay >= 120)                    # 120분 이상 연착한 항공편
flights %>% filter(month == 1 & day == 1)               # 1월 1일에 출발한 항공편
flights %>% filter(month %in% c(3,5,8))                 # 3,5,8월에 출발한 항공편
```


#### arrange() 함수
+ 특정 변수를 기준으로 행 정렬, 기본값(default)은 오름차순
+ 정렬 기준 변수가 여러 개인 경우 순차적으로 적용
+ ```desc()``` 함수 - 내림차순 정렬

```{r eval = FALSE}
flights %>% arrange(year, month, day, dep_time)
filghts %>% arrange(desc(dep_delay))                    # 가장 늦게 출발한 항공편 확인
flights %>%
  filter(dep_delay <= 10 & dep_dalay >= -10) %>%        # 대략 정시에 출발한 항공편 중에서 
  arrange(desc(arr_delay))                              # 가장 늦게 도착한 항공편 확인
```


### 열 관련 함수


#### select() 함수
+ 특정 변수 추출
+ 추출한 변수명을 바꿀 수 있음
+ 도우미(helpers) 함수
  + ```starts_with()``` 함수 - 특정 문자열로 시작하는 이름 매칭
  + ```ends_with()``` 함수 - 특정 문자열로 끝나는 이름 매칭
  + ```contains()``` 함수 - 특정 문자열을 포함하는 이름 매칭
  + ```num_range("x", 1:3)``` 함수 - x1, x2, x3 매칭

```{r eval = FALSE}
flights %>% select(year, month, day)                  # 출발 연월일 변수 추출
flights %>% select(year:day)
flights %>% select(-(year:day))                       # 출발 연월일 변수 제외
flights %>%
  select(dep.time = dep_time, arr.time = arr_time)    # 변수명 변경
flights %>% select(starts_with("sched"))              # 변수명 "sched"로 시작하는 경우
flights %>% select(ends_with("time"))                 # 변수명 "time"으로 끝나는 경우
flights %>% select(contains("arr"))                   # 변수명 "arr"를 포함하는 경우
```


#### rename() 함수
+ 특정 변수명 변경
+ 명시적으로 언급하지 않은 모든 변수를 유지함

```{r eval = FALSE}
flights %>% rename(dep.time = dep_time, arr.time = arr_time)
```


#### mutate() 함수
+ 데이터셋에 존재하는 변수로부터 새로운 변수 생성
+ 새로운 변수는 항상 데이터셋 마지막 열에 추가됨
  + 매개변수 ```.before``` - 새로운 변수를 특정 위치의 앞에 추가
  + 매개변수 ```.after``` - 새로운 변수를 특정 위치의 뒤에 추가

```{r eval = FALSE}
flights %>% mutate(gain = dep_delay - arr_delay)                      # 출발 지연 - 도착 지연(분)
flights %>% mutate(speed = distance / (air_time/60), .before = 1)     # 첫번째 변수 앞에 추가
flights %>% mutate(hour = air_time / 60, .after = air_time)           # air_time 변수 뒤에 추가
```


#### relocate() 함수
+ 변수 위치 변경, 기본값(default)은 첫번째 열
+ ```mutate()``` 함수와 같이 매개변수 ```.before```, ```.after```를 이용하여 위치 지정

```{r eval = FALSE}
flights %>% relocate(air_time, distance)
flights %>% relocate(carrier:tailnum, .before = day)
```


### 그룹 관련 함수

#### summarise() 함수
+ 통계량 계산하여 하나의 행으로 요약
+ 여러 개의 다양한 요약함수 사용 가능
+ ```n()``` 함수 - 그룹별 크기 계산

```{r eval = FALSE}
flights %>% summarise(mean = mean(air_time, na.rm = TRUE),           # 평균
                      std_dev = sd(air_time, na.rm = TRUE),          # 표준편차
                      n = n())                                       # 데이터 개수
```


#### group_by() 함수
+ 특정 변수를 기준으로 그룹화
+ 일반적으로 summarise()와 함께 사용
+ 여러 변수를 기준으로 그룹화 가능
+ ```ungroup()``` 함수 - 그룹화 제거

```{r eval = FALSE}
flights %>% group_by(month)                           # 데이터 변화 x, 그룹화되어 있음
flights %>% group_by(month) %>%                       # 월별 평균 출발 지연 시간, 그룹 크기
              summarise(delay = mean(dep_delay, na.rm = TRUE), n = n())
flights %>% group_by(year, month, day) %>% summarise(n = n())
flights %>% group_by(month) %>% ungroup() %>% summarise(n = n())     # 그룹화 제거
```


----------------------------------------------------------------------


## tidyr 패키지


### wide format과 long format
+ wide format
  + 사람이 읽기 좋은 데이터 구조
  + 통계학에서 다루는 데이터 테이블 구조와 동일한 개념
  + 각 행은 관측 단위(사람, 가구 등)를 나타내며, 각 열은 관측 단위에 대한 측정값(키, 몸무게 등)으로 표현된 형태
+ long format
  + 컴퓨터가 이해하기 편한 데이터 구조
  + 각 행은 wide format에서 특정 셀의 정보를 반영하며, 각 열은 요인(factor)으로 표현된 형태
  + wide format보다 유연하여 데이터 추가 및 삭제 용이

![](./img/fig5-1.png)


<br>

+ [예제] WHO에서 발표한 1999~2000년 3개 국가(아프가니스탄, 브라질, 중국)의 결핵 사례 수
  + 동일한 데이터셋을 다양한 format으로 보여줌

```{r eval = FALSE}
library(tidyr)
table1
table2
table3
table4a
table4b
```


### long format으로 변환
+ wide format을 long format으로 변환 - ```pivot_longer()``` 함수(권장)
  + 행의 개수를 늘리고 열의 개수를 줄여서 데이터셋을 길게 만듬
  + long format으로 변환하고자 하는 열을 지정하는 방법은 ```dplyr::select()``` 함수와 동일
  + [참고] ```gather()```, ```reshape2::melt()``` 함수

```{r eval = FALSE}
## Example 1
table4a %>%
  pivot_longer(c(`1999`, `2000`), names_to = "year", values_to = "cases") %>% 
  mutate(year = parse_integer(year))                 # year 변수를 정수형으로 변경

table4b %>% 
  pivot_longer(c(`1999`, `2000`), names_to = "year", values_to = "population") %>% 
  mutate(year = parse_integer(year))                 # year 변수를 정수형으로 변경


## Example 2
relig_income %>%
  pivot_longer(-religion, names_to = "income", values_to = "count")


## Example 3
billboard %>%
  pivot_longer(cols = starts_with("wk"),             # dplyr::select()의 helpers 함수 사용
               names_to = "week",
               names_prefix = "wk",
               values_to = "rank",
               values_drop_na = TRUE)                # 결측값(NA) 제거
```


### wide format으로 변환
+ long format을 wide format으로 변환 - ```pivot_wider()``` 함수(권장)
  + 관측값이 여러 행에 흩어져 있을 때 사용
  + [참고] ```spread()```, ```reshape2::dcast()``` 함수

```{r eval = FALSE}
## Example 1
table2 %>%
  pivot_wider(names_from = type,
              values_from = count) %>%                            # type에 대한 wide format
  mutate(rate = cases/population*100000) %>%                      # 인구 10만 명당 결핵 건수
  pivot_wider(names_from = year,                                  # year에 대한 wide format
              values_from = c(cases, population, rate)) %>%
  relocate(country, contains("1999"))                             # 변수 위치 변경


## Example 2
fish_encounters %>%
  pivot_wider(names_from = station,
              values_from = seen,
              values_fill = 0)                                    # 결측값(NA)은 0으로 대체
```


### 열의 분리 및 결합
+ 하나의 열에 저장되어 있는 여러 개의 변수를 분리 - ```separate()``` 함수
+ 여러 개의 열을 하나의 열로 결합 - ```unite()``` 함수

```{r eval = FALSE}
table3 %>% separate(col = rate, into = c("cases", "population"), sep = "/")
table5 %>% unite(col = new_year, century, year)
```


### 결측값(missing value) 처리
+ 결측값 ```NA```은 누락된 값(not availables)을 나타냄
+ 결측값은 알 수 없으므로, 전염성(contagious)을 가짐
  + 결측값에 대한 산술연산, 비교연산 결과도 알 수 없음(NA)
+ 결측값 확인 - ```is.na()``` 함수
```{r eval = FALSE}
NA + 10
NA / 2
NA > 5
10 == NA

# Let x be Mary's age. We don't know how old she is.
# Let y be John's age. We don't know how old he is.
# Are Mary and John the same age?
# We don't know!
NA == NA

is.na(NA)
```


<br>

+ 명시적 결측값(explicitly missing value) - ```NA```로 표시된 값
+ 암묵적 결측값(implicitly missing value) - 데이터셋에 존재하지 않는 값

```{r eval = FALSE}
# 2015년 4분기 수익은 NA로 표시되어 있으므로, 명시적 결측값임
# 2016년 1분기 수익은 데이터셋이 존재하지 않으므로, 암묵적 결측값임
stocks <- tibble(
  year   = c(2015, 2015, 2015, 2015, 2016, 2016, 2016),
  qtr    = c(   1,    2,    3,    4,    2,    3,    4),
  return = c(1.88, 0.59, 0.35,   NA, 0.92, 0.17, 2.66))

stocks %>%
  pivot_wider(names_from = year,                     # year를 열로 pivot하여 명시적으로 만듬
              values_from = return) %>%
  pivot_longer(cols = c(`2015`, `2016`),             # 명시적 결측값이 중요하지 않다면
               names_to = "year",                    # 암묵적으로 만듬(NA 제거)
               values_to = "return",
               values_drop_na = TRUE)
```


<br>

+ 입력한 열의 고유한 모든 조합을 찾은 후, 필요한 경우 명시적 결측값을 채움 - ```complete()``` 함수
+ 결측값을 가장 최근에 존재하는 값(이월된 마지막 관측값)으로 대체 - ```fill()``` 함수
+ 결측값이 존재하는 행 제거 - ```drop_na()``` 함수
+ 결측값을 특정 값으로 대체 - ```replace_na()``` 함수

```{r eval = FALSE}
## Example for complete()
stocks %>% complete(year, qtr)


## Example for fill()
tibble(person = c("Derrick Whitmore", NA, NA, "Katherine Burke"),
       treatment = c(1, 2, 3, 1), response = c(7, 10, 9, 4)) %>% 
  fill(person)


## Example for drop_na()
mytbl <- tibble(x = c(1, 2, NA), y = c("a", NA, "b"))
mytbl %>% drop_na(x)                                # x 변수에서 결측값이 있는 행 제거
mytbl %>% drop_na()                                 # 모든 변수에 대해 결측값이 있는 행 제거


## Example 1 for replace_na()
# 데이터 프레임에 있는 결측값을 대체하는 경우, 매개변수 replace는 list로 입력
# x 변수의 결측값은 0, y 변수의 결측값은 "unknown"으로 대체
mytbl %>% replace_na(list(x = 0, y = "unknown"))

# 벡터에 있는 결측값을 대체하는 경우, 매개변수 replace는 단일 값(single value)으로 입력
mytbl$x %>% replace_na(0)
mytbl$y %>% replace_na("unknown")
mytbl %>% mutate(x = replace_na(x, 0), y = replace_na(y, "unknown"))
```


----------------------------------------------------------------------


## stringr 패키지


### stringr 패키지 소개
+ 문자열(string)을 다루는 함수 제공
+ 모든 함수가 ```str_```로 시작하여 일관성있게 설계됨


### 문자열 기초


#### str_length() 함수
+ 문자열에서 문자의 개수(길이) 확인

```{r eval = FALSE}
## Example 1
library(stringr)
str_length(c("a", "R for data science", NA))


## Example 2
# dplyr::count() 함수 - 그룹별 빈도 값 산출
#        매개변수 wt - 기본값은 NULL로 각 그룹의 행 개수 계산,
#                      변수를 입력하면 각 그룹에 대한 합계 계산
library(babynames)
babynames%>% 
  count(length = str_length(name), wt = n)          # 이름 길이의 분포

babynames %>% 
  filter(str_length(name) == 15) %>%                # 가장 긴 이름 찾기
  count(name, wt = n, sort = TRUE)
```


#### str_sub() 함수
+ 문자열에서 특정 위치의 문자 추출
+ 매개변수 ```start```, ```end```도 포함되기 때문에 반환되는 문자열의 길이는 end - start + 1임

```{r eval = FALSE}
# Example 1
x <- c("Apple", "Banana", "Pear")
str_sub(x, 1, 3)                         # 문자열의 1번째 문자부터 3번째 문자까지 추출
str_sub(x, -3, -1)                       # 문자열의 마지막에서 3번째 문자부터 마지막 문자까지 추출
str_sub("a", 1, 5)                       # 문자열이 너무 짧을 때도 에러는 발생하지 않음!


# Example 2
babynames %>% 
  mutate(first = str_sub(name, 1, 1),    # 이름의 첫번째 문자 추출
         last = str_sub(name, -1, -1))   # 이름의 마지막 문자 추출
```


#### str_to_lower(), str_to_upper() 함수
+ 대소문자 변환
+ 언어마다 대소문자 변경 규칙이 다르기 때문에 주의해야 함

```{r eval = FALSE}
str_to_lower(c("Apple", "Banana", "Pear"))
str_to_upper(c("Apple", "Banana", "Pear"))
```


### 데이터에서 문자열 생성


#### str_c() 함수
+ 두 개 이상의 벡터에 대해 원소별로 결합하여 단일 문자형 벡터(single character vector)로 만듬
+ 매개변수 ```sep``` - 입력된 벡터 결합할 때 사용하는 문자
+ 매개변수 ```collapse``` - 입력된 벡터를 단일 문자열(single string)로 결합할 때 사용하는 문자
+ 결측값(NA)에 대한 결과는 결측값임
+ ```dplyr::mutate()``` 함수와 함께 사용

```{r eval = FALSE}
str_c("Letter: ", letters)
str_c("Letter", letters, sep = ": ")
str_c(letters, " is for", "...")
str_c(letters[-26], " comes before ", letters[-1])

# 단일 문자열(single string)로 결합
str_c(letters, collapse = "")
str_c(letters, collapse = ", ")

# 결측값(NA)이 있는 경우
str_c(c("a", NA, "b"), "-d")

# dplyr::mutate()와 함께 사용
info <- tibble(name = c("Kim", "Lee", "Park"))
info %>% mutate(greeting = str_c("Hi, ", name, "!"))
```


#### str_glue() 함수
+ 고정 문자열과 변수 문자열을 결합할 때 ```""```를 반복적으로 타이핑하는 것을 방지하여 가독성을 높임
+ ```{}```안에 작성된 코드는 문자열 외부에 있는 것처럼 실행

```{r eval = FALSE}
info <- tibble(name = c("Kim", "Lee", "Park"))
info %>% mutate(greeting = str_glue("Hi, {name}!"))
```


#### str_flatten() 함수
+ 벡터의 각 요소를 하나의 문자열로 결합
+ ```dplyr::summarise()``` 함수와 함께 사용

```{r eval = FALSE}
## Example 1
str_flatten(c("x", "y", "z"))
str_flatten(c("x", "y", "z"), collapse = ", ")
str_flatten(c("x", "y", "z"), collapse = ", ", last = ", and ")


## Example 2
mytbl <- tibble(name = c("Carmen", "Carmen", "Marvin", "Terence", "Terence", "Terence"),
                fruit = c("banana", "apple", "nectarine", "cantaloupe", "papaya", "madarine"))
mytbl %>%
  group_by(name) %>% 
  summarize(fruits = str_flatten(fruit, ", "))
```


### 정규 표현식을 이용한 패턴 매칭


#### 정규 표현식(regular expression; regex, regexp)
+ 주어진 문자열에 특정한 패턴이 있는 경우, 해당 패턴을 일반화(수식화)한 문자열
+ 특정 패턴을 표현한 문자열을 메타 문자(meta character)라 함
+ 일반적으로 특정 패턴을 가지는 문자열을 찾고, 다른 값으로 대체하기 위해 사용

|표현식|설명|
|:---:|:------------|
|.|무엇이든 한 글자를 의미|
|^|^ 뒤에 오는 표현식으로 시작하는 경우|
|\$|\$ 앞에 오는 표현식으로 끝나는 경우|
|?|? 앞에 오는 표현식이 0 또는 1번(0 or 1) 일치하는 경우|
|+|+ 앞에 오는 표현식이 1번 또는 그 이상(1 or more) 일치하는 경우|
|\*|\* 앞에 오는 표현식이 0번 또는 그 이상(0 or more) 포함하는 경우|

```{r eval = FALSE}
x <- c("apple", "banana", "pear")
str_view(x, "an")                        # matching exact strings
str_view(x, ".a.")                       # matching any character(except a newline)
str_view(x, "^a")                        # matching the start of the string
str_view(x, "a$")                        # matching the end of the string

## how many times a pattern mathces?
x <- "1888 is the longest year in Roman numerals: MDCCCLXXXVIII"
str_view_all(x, "CC?")
str_view_all(x, "CC+")
str_view_all(x, "CC*")
```


<br>

+ ```[]```을 사용하여 문자 집합을 매칭함
  + ```[abcd]``` - "a","b","c","d" 중 하나 이상과 매칭
  + ```[^abcd]``` - "a","b","c","d"를 제외한 어느 것과도 매칭

```{r eval = FALSE}
names <- c("Hadley", "Mine", "Garrett")
str_view_all(names, "[aeiou]")
str_view_all(names, "[^aeiou]")
str_view_all(names, "[^aeiou]+")         # 같은 문자가 매칭되었지만 매칭 개수가 다름
```


<br>

+ 정규 표현식에서 특수 동작이 아닌 기호 자체로 사용하기 위해서는 그 앞에 ```\``` 사용
  + 작은 따옴표 ```'\''```
  + 큰 따옴표 ```"\""```
  + 백슬래시 ```"\\\\"```
  + 점(dot) ```\\.```

```{r eval = FALSE}
str_view(c("a\\b"), "\\\\")
str_view(c("abc", "a.c", "bef"), "a\\.c")
```


#### str_detect() 함수
+ 패턴이 일치하면 TRUE 반환
+ 정규 표현식을 적절하게 사용하면 매우 유용함
+ ```dplyr::filter()```와 함께 사용

```{r eval = FALSE}
## Example 1
str_detect(c("apple", "banana", "pear"), "e")


## Example 2
sum(str_detect(words, "^t"))             # t로 시작하는 단어의 개수
mean(str_detect(words, "[aeiou]$"))      # 모음으로 끝나는 단어의 비율


## Example 3
babynames %>% filter(str_detect(name, "x"))

babynames %>% 
  group_by(year) %>% 
  summarise(prop_x = mean(str_detect(name, "x")))
```


#### str_count() 함수
+ ```str_detect()``` 함수의 변형으로, 일치하는 패턴의 개수 반환
+ ```dplyr::mutate()```와 함께 사용

```{r eval = FALSE}
str_count(c("apple", "banana", "pear"), "p")

babynames %>% 
  count(name) %>% 
  mutate(vowels = str_count(name, "[aeiou]"),                     # 모음 개수 확인
         consonants = str_count(name, "[^aeiou]"))                # 자음 개수 확인
```



#### str_replace(), str_replace_all() 함수
+ 일치하는 패턴을 새 문자열로 변경

```{r eval = FALSE}
## Example 1
x <- c("apple", "pear", "banana")
str_replace(x, "[aeiou]", "-")           # 처음으로 일치하는 패턴만 변경
str_replace_all(x, "[aeiou]", "-")       # 일치하는 모든 패턴을 변경


## Example 2
# 벡터를 이용하여 다중 대체(multiple replacement)할 수 있음
x <- c("1 house", "2 cars", "3 people")
str_replace_all(x, c("1" = "one", "2" = "two", "3" = "three"))
```


----------------------------------------------------------------------


## forcats 패키지


### forcats 패키지 소개
+ 팩터(factor)를 다루는 함수 제공
  + 팩터는 범주형 변수에 사용하는 데이터 객체로, 문자형보다 다루기 더 쉬움
  + 범주형 변수는 가질 수 있는 값이 미리 고정되고 알려져 있음
  + 문자형 벡터를 알파벳순이 아닌 순서로 표현하고 싶을 때 유용
+ [예제] General Social Survey
  + 시카고 대학교의 독립연구기관 NORC에서 장기간 수행한 General Social Survey의 샘플 테이터

|변수|설명|
|:---:|:------------|
|year|조사 연도, 2000~2014년(2년 주기)|
|marital|결혼 상태|
|age|연령|
|race|인종|
|rincome|소득|
|partyid|정치 성향|
|relig|종교|
|denom|교파|
|tvhours|하루 TV 시청 시간|

```{r eval = FALSE}
library(stringr)
gss_cat
```


### 팩터 수준(levels) 재정렬
+ 처음 나타나는 순서대로 재정렬 - ```fct_inorder()``` 함수
+ 각 수준의 빈도가 큰 순서대로 재정렬 - ```fct_infreq()``` 함수
+ 수준의 수치 값(numeric value) 순서대로 재정렬 - ```fct_inseq()``` 함수
+ 팩터 수준을 반대로 재정렬 - ```fct_rev()``` 함수

```{r eval = FALSE}
fct1 <- factor(c("b", "b", "a", "c", "c", "c"))
fct_inorder(fct1)                                    # Levels: b a c
fct_infreq(fct2)                                     # Levels: c b a


fct2 <- factor(1:3, levels = c("2", "3", "1"))
fct_inseq(fct2)                                      # Levels : 1 2 3

fct_rev(fct1)
fct_rev(fct2)

# fct_infreq(), fct_rev()는 조합해서 사용 가능
# marital 수준은 각 수준의 빈도에 대해 오름차순으로 재정렬됨
gss_cat %>%
  mutate(marital = marital %>% fct_infreq() %>% fct_rev()) %>%
  ggplot(aes(marital)) + geom_bar()
```


<br>

+ 특정 변수를 기준으로 재정렬 - ```fct_reorder()``` 함수
+ 특정 수준을 맨 앞으로 배치 - ```fct_relevel()``` 함수

```{r eval = FALSE}
## Example for fct_reorder()
# 결혼 상태에 따른 하루 평균 TV 시청 시간
summary1 <- gss_cat %>% 
              group_by(marital) %>% 
              summarise(tvhours = mean(tvhours, na.rm = TRUE),
                        n = n()) %>% 
              mutate(marital = fct_reorder(marital, tvhours))

## [그래프를 통한 확인]
# 하루 평균 TV 시청 시간을 기준으로 marital 수준이 재정렬됨
library(ggplot2)
ggplot(summary1, aes(tvhours, marital)) +
  geom_point(size = 3) +
  theme(axis.title = element_text(size = 15),
        axis.text = element_text(size = 15))


## Example for fct_relevel()
# 소득에 따른 평균 연령
summary2 <- gss_cat %>%
              group_by(rincome) %>%
              summarise(age = mean(age, na.rm = TRUE), n = n())

## [그래프를 통한 확인]
# reorder() 함수를 사용하면 어떤 소득 집단이 평균 연령이 가장 높고 낮은지 파악하기 쉬우나,
# rincome 변수는 순서형 변수(ordinal variable)이기 때문에 이는 바람직하지 않음
# relevel() 함수를 사용하여 "Not applicable" 수준을 맨 앞으로 배치할 수 있음
ggplot(summary2, aes(age, fct_reorder(rincome, age))) + geom_point()
ggplot(summary2, aes(age, fct_relevel(rincome, "Not applicable"))) + geom_point()
```


### 팩터 수준(levels) 변경
+ ```fct_recode()``` 함수
  + 명시적으로 언급되지 않은 수준은 그대로 유지함
  + 그룹으로 결합하려면 이전 수준을 동일한 새로운 수준에 할당
  + ※ 주의 : 서로 같지 않은 범주를 함께 묶는다면 잘못된 결과를 도출할 수 있음
+ ```fct_collapse()``` 함수
  + 여러 개의 수준을 하나로 병합
  + 새로운 수준에 대해 이전 수준으로 이루어진 벡터를 제공
+ ```fct_lump()``` 함수
  + 상대적으로 빈도가 낮은 소규모 그룹을 하나로 병합
  + 매개변수 ```n``` - Other를 제외한 그룹 개수 지정

```{r eval = FALSE}
## Example 1 for fct_recode()
gss_cat %>%
  mutate(partyid = fct_recode(partyid,
                              "Republican, strong"    = "Strong republican",
                              "Republican, weak"      = "Not str republican",
                              "Independent, near rep" = "Ind,near rep",
                              "Independent, near dem" = "Ind,near dem",
                              "Democrat, weak"        = "Not str democrat",
                              "Democrat, strong"      = "Strong democrat")) %>%
  count(partyid)


## Example 2 for fct_recode()
gss_cat %>%
  mutate(partyid = fct_recode(partyid,
                              "Republican, strong"    = "Strong republican",
                              "Republican, weak"      = "Not str republican",
                              "Independent, near rep" = "Ind,near rep",
                              "Independent, near dem" = "Ind,near dem",
                              "Democrat, weak"        = "Not str democrat",
                              "Democrat, strong"      = "Strong democrat",
                              "Other"                 = "No answer",
                              "Other"                 = "Don't know",
                              "Other"                 = "Other party")) %>%
  count(partyid)


## Example for fct_collapse()
gss_cat %>%
  mutate(partyid = fct_collapse(partyid,
                                other = c("No answer", "Don't know", "Other party"),
                                rep = c("Strong republican", "Not str republican"),
                                ind = c("Ind,near rep", "Independent", "Ind,near dem"),
                                dem = c("Not str democrat", "Strong democrat"))) %>%
  count(partyid)


## Example 1 for fct_lump()
gss_cat %>%
  mutate(relig = fct_lump(relig)) %>%
  count(relig)


## Example 2 for fct_lump()
gss_cat %>%
  mutate(relig = fct_lump(relig, n = 10)) %>%
  count(relig, sort = TRUE) %>%
  print(n = Inf)
```


----------------------------------------------------------------------


## lubridate 패키지


### lubridate 패키지 소개
+ 날짜, 시간을 다루는 함수 제공
+ 핵심 tidyverse에 포함되지 않으므로 별도로 불러와야 함


### 날짜/시간 object


#### 날짜/시간 object 유형
+ **date** object - 날짜를 나타내며, tibble에서 \<date\>로 출력
+ **time** object - 하루 중 시간을 나타내며, tibble에서 \<time\>로 출력
+ **date-time** object - 날짜와 시간을 나타내므로 시점을 고유하게 식별함, tibble에서 \<dttm\>로 출력

```{r eval = FALSE}
today()                                  # 오늘 날짜(date object)
now()                                    # 현재 날짜 및 시간(date-time object)
```


#### 문자열(string)로부터 날짜/시간 object 생성
+ 문자열에서 연(year), 월(month), 일(day)의 순서를 확인한 후, 함수명 "y", "m", "d"를 같은 순서로 배치
+ date-time object를 생성하려면 ```_```와 "h", "m", "s" 중 하나 이상을 추가

```{r eval = FALSE}
library(lubridate)
ymd("2017-01-31")
mdy("January 31st, 2017")
dmy("31-Jan-2017")

ymd_hms("2017-01-31 20:11:59")
mdy_hm("01/31/2017 08:01")
```


#### 개별 구성요소로부터 날짜/시간 object 생성
+ 날짜/시간과 관련된 개별 구성요소들이 여러 열(변수)에 저장되어 있는 경우
+ date object - ```make_date()```  함수
+ date-time object - ```make_datetime()``` 함수

```{r eval = FALSE}
library(nycflights13)

# 예정된 출발 일시
flights %>% 
  select(year, month, day, hour, minute) %>% 
  mutate(departure = make_datetime(year, month, day, hour, minute))
```

```{r eval = FALSE}
# 시간에 대해 HHMM 또는 HMM으로 저장된 값은 시(hour)와 분(minute)으로 나누는 사용자 정의 함수
# [참고] %/% 나눗셈의 몫, %% 나눗셈의 나머지
make_datetime_100 <- function(year, month, day, time) {
  make_datetime(year, month, day, time %/% 100, time %% 100)
}

# 실제 출발 일시, 실제 도착 일시, 예정된 출발 일시, 예정된 도착 일시 생성
flights_dt <- flights %>% 
  filter(!is.na(dep_time), !is.na(arr_time)) %>% 
  mutate(dep_time = make_datetime_100(year, month, day, dep_time),
         arr_time = make_datetime_100(year, month, day, arr_time),
         sched_dep_time = make_datetime_100(year, month, day, sched_dep_time),
         sched_arr_time = make_datetime_100(year, month, day, sched_arr_time)) %>% 
  select(origin, dest, ends_with("delay"), ends_with("time"))
```


#### 기존의 날짜/시간 object로부터 날짜/시간 object 생성
+ date object와 date-time object의 상호 전환 - ```as_datetime()```, ```as_date()``` 함수

```{r eval = FALSE}
as_datetime(today())
as_date(now())
```


### 날짜/시간 구성요소
+ 개별 구성요소 가져오기 - ```year()```, ```month()```, ```week()```, ```day()```, ```hour()```, ```minute()```, ```second()``` 함수
+ 해당 연(year)을 기준으로 몇 번째 일(day)인지 반환 - ```yday()```
+ 해당 월(month)을 기준으로 몇 번째 일(day)인지 반환 - ```mday()```
+ 해당 주(week)에서 무슨 요일인지 반환 - ```wday()```
  + 1은 일요일, 7은 토요일을 의미
+ ```month()```, ```wday()``` 함수 관련 매개변수
  + 매개변수 ```label``` - TRUE이면 문자열, FALSE이면 숫자로 표시
  + 매개변수 ```abbr``` - FALSE이면 이름 전체 반환(label이 FALSE인 경우 무시)

```{r eval = FALSE}
datetime <- ymd_hms("2016-07-08 12:34:56")

year(datetime)
month(datetime)
month(datetime, label = TRUE)
day(datetime)
hour(datetime)
minute(datetime)
second(datetime)

yday(datetime)
mday(datetime)
wday(datetime)
wday(datetime, label = TRUE, abbr = FALSE)
```


### 시간 범위(time spans) object


#### 시간 범위 object 유형
+ **duration** object : 정확한 초(second)를 나타냄
+ **period** object : 주(week)와 월(month)과 같이 사람의 단위(human units)로 표현함
+ **interval** object : 시작 시점과 종료 시점을 나타냄


#### duration object
+ date object에 뺄셈을 적용하면 difftime object가 생성되며, 이는 초(second), 분(minute), 시(hour), 일(day) 또는 주(week) 단위로 시간 범위를 기록하므로 작업이 어려움
+ 이를 보완하기 위한 duration object는 항상 **초(second) 단위**를 사용하여 시간 범위를 나타냄
  + 1분 = 60초, 1시간 = 3600초(60분), 1일 = 86400초(24시간), 1주일 = 604800초(7일)
+ duration object는 덧셈, 뺄셈, 곱셈을 적용할 수 있음
  + 윤년, 일광 절약 시간제(daylight saving time) 같은 규칙의 영향을 받기 때문에 시간(hour), 월(month), 연(year)과 같은 큰 시간 단위로 측정한 값에 대해 연산 결과가 실제와 항상 일치하지 않음
  + [참고] 일광 절약 시간제 - 하절기에 표준시를 원래 시간보다 한 시간 앞당긴 시간을 쓰는 것으로, 미국과 캐나다는 각 시간대의 지역 시간을 기준으로 3월 두 번째주 일요일 오전 2시부터 11월 첫 번째주 일요일 오전 2시까지에 적용함


```{r eval = FALSE}
## duration object 생성
dday <- today() - ymd(19990113)
as.duration(dday)

dseconds(15)
dminutes(10)
dhours(c(12, 24))
ddays(0:5)
dweeks(3)
dmonths(1:6)
dyears(1)


## 산술 연산
2 * dyears(1)
dyears(1) + dweeks(12) + dhours(15)

tomorrow <- today() + ddays(1)
last_year <- today() - dyears(1)

# daylight saving time
one_pm <- ymd_hms("2016-03-12 13:00:00", tz = "America/New_York")
one_pm                                        # "2016-03-12 13:00:00 EST"
one_pm + ddays(1)                             # "2016-03-13 14:00:00 EDT"
```


#### period object
+ 지정된 단위로 period object 생성
+ 사람이 인식하는 단위로, 작동 방식이 보다 직관적임

```{r eval = FALSE}
## period object 생성
seconds(15)
minutes(10)
hours(c(12, 24))
days(0:5)
weeks(3)
months(1:6)
years(1)


## 산술 연산
10 * (months(6) + days(1))
days(50) + hours(25) + minutes(2)

# 윤년
ymd("2016-01-01") + dyears(1)
ymd("2016-01-01") + years(1)

# daylight saving time
one_pm <- ymd_hms("2016-03-12 13:00:00", tz = "America/New_York")
one_pm                                        # "2016-03-12 13:00:00 EST"
one_pm + days(1)                              # "2016-03-13 13:00:00 EDT"


## 심야 항공편의 도착 일시에 days(1)을 더해줌
flights_dt %>% 
  filter(arr_time < dep_time)

flights_dt <- flights_dt %>% 
  mutate(overnight = arr_time < dep_time,
         arr_time = arr_time + days(overnight * 1),
         sched_arr_time = sched_arr_time + days(overnight * 1))

flights_dt %>% 
  filter(overnight, arr_time < dep_time)
```


#### interval object
+ interval object는 시작 시점과 종료 시점을 나타내므로, 정확한 시간 범위를 확인할 수 있음
+ interval object 생성 - ```ineterval()``` 함수, ```%--%``` 연산자
+ 정수 나눗셈을 이용하여 interval object의 기간을 확인할 수 있음

```{r eval = FALSE}
## interval object 생성
next_year <- today() + years(1)
interval(start = today(), end = next_year)    # today() %--% next_year

# interval object 기간 확인
(today() %--% next_year) / ddays(1)
```

